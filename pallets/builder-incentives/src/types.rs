use frame_support::{
	pallet_prelude::*,
	traits::{fungible::Inspect, Currency},
};
use pallet_transaction_payment::OnChargeTransaction;
use sp_core::H160;
use sp_runtime::traits::{Saturating, Zero};

use crate::Config;

pub type AccountIdOf<T> = <T as frame_system::Config>::AccountId;
/// AccountContractId for pallet_revive
pub type AccountContractId = H160;
/// Era number type
pub type EraNumber = u32;
/// An index to a block.
pub type BlockNumber = u32;

/// Type aliases used for interaction with `OnChargeTransaction`.
pub(crate) type OnChargeTransactionOf<T> =
	<T as pallet_transaction_payment::Config>::OnChargeTransaction;

/// OnChargeTransactionBalance type alias.
pub(crate) type OnChargeTransactionBalanceOf<T> =
	<OnChargeTransactionOf<T> as OnChargeTransaction<T>>::Balance;

pub(crate) type ContractsOf<T> = <T as pallet_revive::Config>::Currency;

/// Contracts Balance alias
pub(crate) type ContractsBalanceOf<T> =
	<ContractsOf<T> as Inspect<<T as frame_system::Config>::AccountId>>::Balance;

/// Balance alias
pub(crate) type BalanceOf<T> =
	<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;

/// Liquidity info type alias (imbalances).
pub(crate) type LiquidityInfoOf<T> =
	<OnChargeTransactionOf<T> as OnChargeTransaction<T>>::LiquidityInfo;

/// Information about an era: fees generated, and the next era start.
#[derive(Clone, Encode, Decode, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(T))]
pub struct EraInfo<T: Config> {
	/// Block number at which the next era should start.
	pub(crate) next_era_start: BlockNumber,
	/// Total fees generated by smart contract calls within this era.
	pub(crate) contract_fee_total: BalanceOf<T>,
	/// Total fees generated by all types of calls (both contract and non-contract) within this
	/// era.
	pub(crate) total_fee_amount: BalanceOf<T>,
}

impl<T: Config> Default for EraInfo<T> {
	fn default() -> Self {
		Self {
			next_era_start: 1,
			contract_fee_total: BalanceOf::<T>::zero(),
			total_fee_amount: BalanceOf::<T>::zero(),
		}
	}
}

impl<T: Config> EraInfo<T> {
	/// Block number at which the next era should start.
	pub fn next_era_start(&self) -> BlockNumber {
		self.next_era_start
	}

	/// Set the next era start block number.
	pub fn set_next_era_start(&mut self, next_era_start: BlockNumber) {
		self.next_era_start = next_era_start;
	}

	/// Checks whether a new era should be triggered.
	pub fn is_new_era(&self, now: BlockNumber) -> bool {
		self.next_era_start <= now
	}

	/// Increases the total fees generated by smart contract calls for the current era.
	pub fn add_contract_fee(&mut self, amount: BalanceOf<T>) {
		self.contract_fee_total = self.contract_fee_total.saturating_add(amount);
	}

	/// Increases the total fees generated by all calls for the current era.
	pub fn add_total_fee(&mut self, amount: BalanceOf<T>) {
		self.total_fee_amount = self.total_fee_amount.saturating_add(amount);
	}

	/// Reset the total fees generated by smart contract calls for the current era.
	pub fn reset_contract_fee(&mut self) {
		self.contract_fee_total = BalanceOf::<T>::zero();
	}

	/// Reset the total fees generated by all calls for the current era.
	pub fn resent_total_fee(&mut self) {
		self.total_fee_amount = BalanceOf::<T>::zero();
	}
}

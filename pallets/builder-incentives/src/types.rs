use crate::Config;
use frame_support::{
	pallet_prelude::*,
	traits::{fungible::Inspect, Currency},
};
use pallet_transaction_payment::OnChargeTransaction;
use sp_core::H160;
use sp_runtime::Saturating;

pub type AccountIdOf<T> = <T as frame_system::Config>::AccountId;
/// Era number type
pub type EraNumber = u32;
/// An index to a block.
pub type BlockNumber = u32;

/// Type aliases used for interaction with `OnChargeTransaction`.
pub(crate) type OnChargeTransactionOf<T> =
	<T as pallet_transaction_payment::Config>::OnChargeTransaction;

// /// Balance type alias.
// pub(crate) type BalanceOf<T> = <OnChargeTransactionOf<T> as OnChargeTransaction<T>>::Balance;
// pub(crate) type BalanceOf<T> =
// 	<Currency<T> as Currency<<T as frame_system::Config>::AccountId>>::Balance;
// pub(crate) type CurrencyOf<T> = <OnChargeTransactionOf<T> as OnChargeTransaction<T>>::Currency;
// pub(crate) type BalanceOf<T> =
// 	<<T as Config>::Currency as Currency<<T as SystemConfig>::AccountId>>::Balance;
/// Contracts Balance type
pub(crate) type ContractsOf<T> = <T as pallet_contracts::Config>::Currency;

/// Contracts Balance alias
pub(crate) type ContractsBalanceOf<T> =
	<ContractsOf<T> as Inspect<<T as frame_system::Config>::AccountId>>::Balance;

pub(crate) type MainBalanceOf<T> =
	<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;
/// Liquidity info type alias (imbalances).
pub(crate) type LiquidityInfoOf<T> =
	<OnChargeTransactionOf<T> as OnChargeTransaction<T>>::LiquidityInfo;

/// Trait defining the interface for dApp staking `smart contract types` handler.
///
/// It can be used to create a representation of the specified smart contract instance type.
pub trait SmartContractHandle<AccountId> {
	/// Create a new smart contract representation for the specified EVM address.
	fn evm(address: H160) -> Self;
	/// Create a new smart contract representation for the specified Wasm address.
	fn wasm(address: AccountId) -> Self;
}

/// Multi-VM pointer to smart contract instance.
#[derive(
	PartialEq,
	Eq,
	Copy,
	Clone,
	Encode,
	Decode,
	RuntimeDebug,
	MaxEncodedLen,
	Hash,
	scale_info::TypeInfo,
)]
pub enum SmartContract<AccountId> {
	/// EVM smart contract instance.
	Evm(H160),
	/// Wasm smart contract instance.
	Wasm(AccountId),
}

impl<AccountId> SmartContractHandle<AccountId> for SmartContract<AccountId> {
	fn evm(address: H160) -> Self {
		Self::Evm(address)
	}

	fn wasm(address: AccountId) -> Self {
		Self::Wasm(address)
	}
}

/// Information about an era, fees generated, and the next era start.
#[derive(Clone, Encode, Decode, Default, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(T))]
pub struct EraInfo<T: Config> {
	/// Block number at which the next era should start.
	pub(crate) next_era_start: BlockNumber,
	/// Total fees generated by smart contract calls within this era.
	pub(crate) contract_fee_total: MainBalanceOf<T>,
	/// Total fees generated by all types of calls (both contract and non-contract) within this era.
	pub(crate) total_fee_amount: MainBalanceOf<T>,
}

impl<T: Config> EraInfo<T> {
	/// Block number at which the next era should start.
	pub fn next_era_start(&self) -> BlockNumber {
		self.next_era_start
	}

	/// Set the next era start block number.
	/// Not perfectly clean approach but helps speed up integration tests significantly.
	pub fn set_next_era_start(&mut self, next_era_start: BlockNumber) {
		self.next_era_start = next_era_start;
	}

	/// Checks whether a new era should be triggered, based on the provided _current_ block number argument
	/// or possibly other protocol state parameters.
	pub fn is_new_era(&self, now: BlockNumber) -> bool {
		self.next_era_start <= now
	}

	/// Increases the total fees generated by smart contract calls for the current era.
	pub fn add_contract_fee(&mut self, amount: MainBalanceOf<T>) {
		self.contract_fee_total = self.contract_fee_total.saturating_add(amount);
	}
	/// Increases the total fees generated by all calls for the current era.
	pub fn add_total_fee(&mut self, amount: MainBalanceOf<T>) {
		self.total_fee_amount = self.total_fee_amount.saturating_add(amount);
	}
}
